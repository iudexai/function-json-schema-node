{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { z } from 'zod';\n\n/**\n * Recursive JSON object schema\n */\nexport type ObjectJsonSchema = {\n  type: 'object',\n  properties: Record<string, ValueJsonSchema>,\n  description?: string;\n}\n\ntype RecordJsonSchema = {\n  type: 'object',\n  additionalProperties: ValueJsonSchema,\n  description?: string;\n}\n\ntype ArrayJsonSchema = {\n  type: 'array',\n  items: ValueJsonSchema,\n  description?: string;\n}\n\nconst objectJsonSchema: z.ZodType<ObjectJsonSchema> = z.object({\n  type: z.literal('object'),\n  properties: z.record(z.lazy(() => valueJsonSchema)),\n  description: z.string().optional(),\n  required: z.array(z.string()).optional(),\n});\n\nconst recordJsonSchema: z.ZodType<RecordJsonSchema> = z.object({\n  type: z.literal('object'),\n  additionalProperties: z.lazy(() => valueJsonSchema),\n  description: z.string().optional(),\n});\n\nconst arrayJsonSchema: z.ZodType<ArrayJsonSchema>  = z.object({\n  type: z.literal('array'),\n  items: z.lazy(() => valueJsonSchema),\n  description: z.string().optional(),\n});\n\nconst tupleJsonSchema = z.object({\n  type: z.literal('array'),\n  prefixItems: z.array(z.string()),\n  description: z.string().optional(),\n});\n\nconst stringJsonSchema = z.object({\n  type: z.literal('string'),\n  enum: z.array(z.string()).optional(),\n  description: z.string().optional(),\n});\n\nconst numberJsonSchema = z.object({\n  type: z.union([z.literal('number'), z.literal('integer')]),\n  description: z.string().optional(),\n  minimum: z.number().optional(),\n  maximum: z.number().optional(),\n});\n\nconst booleanJsonSchema = z.object({\n  type: z.literal('boolean'),\n  description: z.string().optional(),\n});\n\n/**\n * This is not the real way to represent union types in JSON Schema.\n * The real way sucks.\n */\nconst unionJsonSchema = z.object({\n  type: z.array(z.string()),\n  description: z.string().optional(),\n});\n\ntype RealUnionJsonSchema = {\n  anyOf: ValueJsonSchema[],\n  description?: string;\n}\n/**\n * The real way to represent unions\n */\nconst realUnionJsonSchema: z.ZodType<RealUnionJsonSchema>  = z.object({\n  anyOf: z.array(z.lazy(() => valueJsonSchema)),\n  description: z.string().optional(),\n});\n\nconst unknownJsonSchema = z.object({\n  type: z.literal('unknown'),\n  description: z.string().optional(),\n});\n\nconst nullJsonSchema = z.object({\n  type: z.literal('null'),\n  description: z.string().optional(),\n});\n\nconst refJsonSchema = z.object({\n  $ref: z.string(),\n  description: z.string().optional(),\n});\n\nconst valueJsonSchema = z.union([\n  objectJsonSchema,\n  recordJsonSchema,\n  arrayJsonSchema,\n  tupleJsonSchema,\n  stringJsonSchema,\n  numberJsonSchema,\n  booleanJsonSchema,\n  unionJsonSchema,\n  realUnionJsonSchema,\n  unknownJsonSchema,\n  nullJsonSchema,\n  refJsonSchema,\n]);\nexport type ValueJsonSchema = z.infer<typeof valueJsonSchema>;\n\n/**\n * OpenAI function json schema\n */\nexport const functionJsonSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  parameters: z.union([\n    z.object({\n      type: z.literal('object'),\n      properties: z.record(valueJsonSchema),\n      description: z.string().optional(),\n      required: z.array(z.string()).optional(),\n    }),\n    z.array(valueJsonSchema),\n  ]),\n  returns: valueJsonSchema,\n  usageExample: z.string().optional(),\n  returnsExample: z.string().optional(),\n});\nexport type FunctionJson = z.infer<typeof functionJsonSchema>;\n\nexport const nullFunctionJson: FunctionJson = {\n  name: '',\n  description: '',\n  parameters: [],\n  returns: { type: 'null' },\n};\n\n/**\n * Set of schemas that coerce values into a valid json schema.\n */\nconst coerceObjectJsonSchema: z.ZodType<ObjectJsonSchema> = z.object({\n  type: z.literal('object'),\n  properties: z.record(z.lazy(() => coerceValueJsonSchema)),\n  description: z.coerce.string().optional(),\n  required: z.array(z.coerce.string()).optional().catch([]),\n});\n\nconst coerceRecordJsonSchema: z.ZodType<RecordJsonSchema>= z.object({\n  type: z.literal('object'),\n  additionalProperties: z.lazy(() => coerceValueJsonSchema),\n  description: z.string().optional(),\n});\n\nconst coerceArrayJsonSchema: z.ZodType<ArrayJsonSchema> = z.object({\n  type: z.literal('array'),\n  items: z.lazy(() => coerceValueJsonSchema),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceTupleJsonSchema = z.object({\n  type: z.literal('array'),\n  prefixItems: z.array(z.coerce.string()),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceStringJsonSchema = z.object({\n  type: z.literal('string'),\n  enum: z.array(z.string()).optional(),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceNumberJsonSchema = z.object({\n  type: z.union([z.literal('number'), z.literal('integer')]),\n  description: z.coerce.string().optional(),\n  minimum: z.number().optional(),\n  maximum: z.number().optional(),\n});\n\nconst coerceBooleanJsonSchema = z.object({\n  type: z.literal('boolean'),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceUnionJsonSchema = z.object({\n  type: z.array(z.coerce.string()),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceRealUnionJsonSchema: z.ZodType<RealUnionJsonSchema>  = z.object({\n  anyOf: z.array(z.lazy(() => valueJsonSchema)),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceUnknownJsonSchema = z.object({\n  type: z.literal('unknown'),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceNullJsonSchema = z.object({\n  type: z.literal('null'),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceRefJsonSchema = z.object({\n  $ref: z.string(),\n  description: z.coerce.string().optional(),\n});\n\nconst coerceValueJsonSchema = z.union([\n  coerceObjectJsonSchema,\n  coerceRecordJsonSchema,\n  coerceArrayJsonSchema,\n  coerceTupleJsonSchema,\n  coerceStringJsonSchema,\n  coerceNumberJsonSchema,\n  coerceBooleanJsonSchema,\n  coerceUnionJsonSchema,\n  coerceRealUnionJsonSchema,\n  coerceUnknownJsonSchema,\n  coerceNullJsonSchema,\n  coerceRefJsonSchema,\n]);\n\n/**\n * Coerces object into function json schema.\n * Defaults values for bad fields when possible.\n */\nexport const coerceFunctionJsonSchema = z.object({\n  name: z.string(),\n  description: z.coerce.string(),\n  parameters: z.object({\n    type: z.literal('object').transform(() => 'object' as const),\n    properties: z.record(\n      coerceValueJsonSchema.catch({ type: 'unknown', description: '' }),\n    ).catch({}),\n    description: z.string().optional().catch(undefined),\n    required: z.array(z.string()).optional().catch(undefined),\n  }).passthrough(),\n  returns: coerceValueJsonSchema.catch({ type: 'unknown', description: '' }),\n}).passthrough();\nexport type CoercedFunctionJson = z.infer<typeof coerceFunctionJsonSchema>;\n\n\n// Helper types for compile time type tests\ntype Expect<T extends true> = T;\ntype Extends<DERIVED_VALUE, VALUE> = DERIVED_VALUE extends VALUE\n  ? true\n  : false;\n\n// Expect CoercedFunctionJson to fit into FunctionJson\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Test1 = Expect<Extends<CoercedFunctionJson, FunctionJson>>;\n"],"mappings":"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","names":[]}